---
title: 初探Nix-01-包与Flake
createTime: 2024/09/14 15:36:04
permalink: /article/szm6xukr/
---

笔者认为，要熟练掌握某项技术或工具，就需要深入地亲自体会它，强迫自己进入“探索-碰壁-再探索”这一良性循环。学习某一语言如此，学习使用某个工具亦如。

以笔者本人为例，笔者以大一的某次比赛为契机接触了Linux，并花费进一年的时间扎根于Linux系统的使用，从Ubuntu到Manjaro，再到ArchLinux，最后深入NixOS，这个过程为笔者带来了大量的实践经验。

笔者举上面的例子旨在说明，学习Nix的过程十分艰难，我们如果认定学习Ubuntu的难度不高，学习Arch的难度较高，那么学习Nix的难度就是非常高。因为它不像Arch那样有完整的文档和成熟的社区支持，Nix的文档是灾难性的——它分布及广、信息量低且几乎没有中文支持。

为了解决一些共性问题和分享一些见解，笔者计划编写新的系列文章，本文是该系列文章的第一篇。

## 所以，什么是Nix？

事实上，上文我们将Nix与其他Linux发行版并列的做法是错误的，严格意义上说，Nix可以是一门编程语言，也可以是一个通用Linux包管理器，但它实际上不是发行版本身。而基于Nix包管理器的Linux发行版被称为NixOS。

> 事实上，社区还维护了一个基于Nix的发行版，叫做[NixNG](https://github.com/nix-community/NixNG)，这里不做讨论

Nix是一个“函数式”的软件包管理器，它以配置文件的方式管理系统中所有的软件和其配置，这样的好处是，其完全遵守函数式编程中纯函数的理念，能够保证同样的配置文件能够产出完全相同的配置结果。

当然，Nix的神秘魅力并不能用上面那句“假大空”的宣传语概括，只有我们深入了解它，我们才能体会到它带给我们的各种便利。

## Flake

> 到现在为止，Flake在事实上仍然是一个实验性项目，但鉴于其使用的广泛程度，本文不会介绍旧的配置方法，而是直接使用Flake

Flake是Nix生态最重要的组成部分，它是大多数Nix项目的基石。

Flake本质上是一个函数，它接受其他Flakes作为输入，并返回一个巨大的结构，其返回内容可以是一个软件包、一个开发环境、一个系统配置等等。

举个例子，我的项目是一个软件`my-tool`，那么我就可以使用Flake将我的软件分发给其他Nix使用者，其他人拿到我的软件包，只需要运行`nix build .`就可以构建我的软件，如果他们想要使用我的软件，只要将我的Flake加入到他们系统的Flake中，就可以在整个系统中安装我的软件。

要创建一个Flake，需要在任意项目的根目录初始化一份`flake.nix`，下面是一个简单的Flake：

```nix
{
  description = "A base nix flake template";

  inputs = {
    
  };
}
```
